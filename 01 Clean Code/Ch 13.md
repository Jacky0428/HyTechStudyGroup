# Ch13 併發編成

## 為何需要併發?

**併發是一種解耦策略。 它幫助我們把完成的事情與完成時間解耦。**
在單執行緒應用程式中，做什麼事情和何時做如此緊密地耦合，以至於整個應用程式的狀態通常可以透過檢視堆疊回溯來確定。 除錯此類系統的程式設計師可以設定斷點或斷點序列，並瞭解斷點被擊中的系統狀態。
從什麼時候解耦可以顯著改善應用程式的吞吐量和結構。 從結構的角度來看，該應用程式看起來像許多小協作計算機，而不是一個大的主迴圈。 這可以使系統更容易理解，並提供一些強大的方法來分離問題。

例如，考慮Web應用程式的標準“Servlet”模型。 這些系統在Web或EJB容器的保護傘下執行，該容器為您部分管理一致性。 每當Web請求出現時，servlet都會非同步執行。 Servlet程式設計師不必管理所有傳入的請求。 原則上，每個servlet執行都生活在自己的小世界裡，並與所有其他servlet執行脫鉤。

事實上，Web容器提供的解偶方式遠遠不完美。 Servlet程式設計師必須非常清楚，並且非常小心，以確保他們的併發程式是正確的。 儘管如此，servlet模型的結構效益是顯著的。 但結構並不是採用併發的唯一動機。 一些系統有響應時間和吞吐量限制，需要手工編碼的併發解決方案。 例如，考慮一個單執行緒資訊聚合器，它從許多不同的網站獲取資訊，並將這些資訊合併到每日摘要中。 因為這個系統是單執行緒的，它依次訪問每個網站，總是在開始下一個網站之前完成一個。 每日執行需要在24小時內執行。 然而，隨著越來越多的網站被新增，時間越來越長，直到收集所有資料需要超過24小時。 單執行緒涉及在Web套接字處等待I/O完成。 我們可以透過使用多執行緒演算法來提高效能，該演算法一次訪問多個網站。

或者考慮一個一次處理一個使用者，每個使用者只需要一秒鐘的系統。 該系統對少數使用者來說是相當響應的，但隨著使用者數量的增加，系統的響應時間也會增加。 沒有使用者想排在其他150人後面！ 我們可以透過同時處理許多使用者來改善該系統的響應時間。

或者考慮一個解釋大型資料集但只能在處理完所有資料集後才能提供完整解決方案的系統。 也許每個資料集都可以在不同的計算機上處理，因此許多資料集是並行處理的


## 13.1 迷失和誤解

- 併發總能改善性能.
  併發有時可以改進性能，但只在多個現成或處理器之間能分享大量等待時間的時候管用.
- 編寫併發程序無須修改設計.
  併發設計與單線程系統設計極不相同，目的與實機的解偶往往對系統產生巨大的影響.
- 使用 Web 或 EJB 容器的時候，理解併發問題並不重要.
  建議了解併發更新、死鎖等問題。

底下是開發併發軟體的建議:
- 併發會在性能和編寫額外代碼上多一些成本.
- 併發是複雜的，哪怕是再簡單的程式.
- 併發的問題並非每次都可複現，所以常常被當偶發性而忽略.
- 併發常常需要對設計的策略作根本性修改.


## 13.2 挑戰

What makes concurrent programming so difficult? Consider the following trivial class:

```
public class X {
private int lastIdUsed;
public int getNextId() { return ++lastIdUsed;
} }
```


假設我們建立一個X的例項，將lastIdUsed欄位設定為42，然後在兩個執行緒之間共享例項。 現在假設這兩個執行緒都呼叫方法getNextId（）；有三個可能的結果：

• Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.
• Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.
• Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.

令人驚訝的第三個結果3發生在兩個執行緒相互踩踏時。 這是因為這兩個執行緒可以透過一行Java程式進行許多可能的路徑，其中一些路徑會產生不正確的結果。 有多少條不同的路徑？ 要真正回答這個問題，我們需要瞭解Just-In-Time編譯器對生成的位元碼做什麼，並瞭解Java記憶體模型認為原子是什麼。 一個快速的答案是，僅使用生成的位程式，在getNextId方法中執行這兩個執行緒有12,870個不同的可能執行路徑4。 如果lastIdUsed的型別從int更改為long，可能的路徑數量將增加到2,704,156。 當然，這些路徑大多會產生有效的結果。 問題是，他們中的一些人沒有。

## 13.3 併發防禦原則

以下是一系列保護系統免受併發程式問題的原則和技術。

### 13.3.1 單一權責

SRP指出，給定的方法/類/元件應該有一個單一的更改原因。 併發設計足夠複雜，足以成為改變自身原因，因此應該與程式的其餘部分分開。 不幸的是，併發實現細節直接嵌入到其他生產程式中太常見了。 以下是一些需要考慮的事情：
- 與併發相關的程式有自己的開發、更改和調優生命週期。
- 併發相關程式有其自身的挑戰，這些挑戰與非併發相關程式不同，而且往往比非併發相關程式更困難。
- 基於併發性的錯誤程式可能會失敗的多種方式，使其在沒有周圍應用程式程式的額外負擔的情況下具有足夠的挑戰性。
-
建議：將您的併發相關程式與其他程式分開。

### 13.3.2 限制數據作用域

正如我們所看到的，修改共享物件同一欄位的兩個執行緒可能會相互干擾，導致意想不到的行為。 一個解決方案是使用同步關鍵字來保護使用共享物件的程式中的關鍵部分。 限制此類關鍵部分的數量很重要。 共享資料可以更新的地方越多，就越有可能：
- 您將忘記保護其中一個或多個地方——破解所有修改共享資料的程式。
- 需要重複工作，以確保一切得到有效保護（違反DRY原則）。
- 很難確定故障的來源，這已經很難找到。
-
建議：將資料封裝放在心上；嚴格限制對任何可能共享的資料的訪問。
### 13.3.3 使用數據複雜

避免共享資料的一個好方法是首先避免共享資料。 在某些情況下，可以複製物件並將其視為只讀。 在其他情況下，可以複製物件，從這些副本中的多個執行緒中收集結果，然後將結果合併到單個執行緒中。

如果有一種簡單的方法來避免共享物件，那麼生成的程式將不太可能造成問題。 您可能擔心所有額外物件建立的成本。 值得嘗試一下，看看這是否確實是個問題。 然而，如果使用物件副本允許程式避免同步，那麼避免內在鎖的節省可能會彌補額外的建立和垃圾收集開銷。
### 13.3.4 線程應盡可能獨立

考慮編寫執行緒程式，使每個執行緒都存在於自己的世界中，不與任何其他執行緒共享資料。 每個執行緒處理一個客戶端請求，其所有所需資料都來自非共享源，並作為本地變數儲存。 這使得每個執行緒都表現得好像它是世界上唯一的執行緒，並且沒有同步要求。 例如，來自HttpServlet的子類類會接收其所有資訊作為引數傳遞給doGet和doPost方法。 這使得每個Servlet的行為就好像它有自己的機器一樣。 只要Servlet中的程式只使用區域性變數，Servlet就不可能導致同步問題。 當然，大多數使用Servlet的應用程式最終會進入共享資源，如資料庫連線。

建議：嘗試將資料劃分為獨立的子集，而不是由獨立執行緒操作，可能在不同的處理器中。

## 13.4 了解函式庫

與以前的版本相比，Java 5為併發開發提供了許多改進。 在Java 5中編寫執行緒程式時，需要考慮幾件事：
- 使用提供的執行緒安全集合。
- 使用執行器框架執行無關的任務。
- 儘可能使用非阻塞解決方案。
- 幾個庫類不是執行緒安全的。

### 線程安全群集

在Java年輕時，Doug Lea寫了開創性的書《Java的併發寫程式》。 與這本書一起，他開發了幾個執行緒安全集合，這些集合後來成為java.util.concurrent軟體包中JDK的一部分。 該包裝時代的收藏品在多執行緒情況下是安全的，並且效能良好。 事實上，ConcurrentHashMap實現在幾乎所有情況下都比HashMap表現更好。 它還允許同時併發讀取和寫入，並且它具有支援常見複合操作的方法，否則執行緒不安全。 如果Java 5是部署環境，請從ConcurrentHashMap開始。
還有幾個支持高併發的類，以下是其中一部分

- ReentrantLock : 可在一個方法中獲取，從另一個方法釋放的鎖
- Semaphore : 有計數器的鎖，經典的信號鎖
- CountDownLatch : 在釋放所有等待鎖之前，等待指定數量事件發生的鎖。這樣可以確保所有線程同時啟動。

建議：檢視可供您使用的課程。 在Java的情況下，熟悉java.util.concurrent、java.util.concurrent.atomic、java.util.concurrent.locks。

## 13.5 了解執行模型
以下是一些常見的併發應用定義.

- 限定資源 : 併發環境有著固定大小或數量的資源，如資料庫連接及固定尺寸讀寫緩存等。
- 互斥 : 每一時刻僅有一個線程能訪問共享數據或共享資源
- 飢餓 : 一個或一組線程在很長時間或被永久禁止。如總是讓執行快的線程先運行，如果快的沒了，執行長的線程就會處於飢餓狀態
- 死鎖 : 兩個或多個以上的線程互相等待對方執行結束，每個線程都需要彼此的資源，得不到其他線程的資源導致無法終止或進行下一步
- 活鎖 : 執行次序一致的線程，每個都想要起步，但發現其它線程已經在執行，然後彼此持續重新嘗試起步，但遲遲無法往後續動作

以下是常見的幾個執行模型


### 13.5.1 生產者-消費者模型(Producer-Consumer)

一個或多個生產者執行緒建立一些工作，並將其置於緩衝區或佇列中。 一個或多個消費者執行緒從佇列中獲取該工作並完成它。 生產者和消費者之間的排隊是一種限定資源。

### 13.5.2 讀者-作者模型(Readers-Writers)

當您有一個共享資源，主要作為讀者的資訊來源，但偶爾由作者更新時，吞吐量是一個問題。 希望防止多個作家同時修改共享資源，並允許兩個或更多讀者同時存取共享資源。 另一方面，如果有頻繁的作家，並且他們被優先考慮，吞吐量將受到影響。 找到這種平衡並避免併發更新問題是解決的問題。


### 13.5.3 宴席哲學家(Dining Philosophers)

想象一下，一些哲學家圍坐在一張圓形桌子旁。 每個哲學家的左邊都放著一個叉子。 桌子中央有一大碗義大利麵。 哲學家們把時間花在思考上，除非他們餓了。 一旦餓了，他們就會拿起兩邊的叉子吃。 哲學家除非拿著兩把叉子，否則不能吃飯。 如果右邊或左邊的哲學家已經在使用他需要的叉子之一，他必須等到那個哲學家吃完並把叉子放回去。 一旦哲學家吃了東西，他就會把兩把叉子放回桌子上，等到他再次餓了。
用執行緒取代哲學家，用資源取代叉子，這個問題類似於許多企業應用程式，其中流程爭奪資源。 除非精心設計，否則以這種方式競爭的系統可能會經歷死鎖、活鎖、吞吐量和效率下降。


您可能會遇到的大多數併發問題將是這三個問題的一些變化。 研究這些演算法，並自行編寫解決方案，這樣當您遇到併發問題時，您將更準備好解決問題。
建議：學習這些基本演算法並瞭解其解決方案。


## 13.6 警惕同步方法的依賴
同步方法之間的依賴會導致併發代碼中的狡猾缺陷，Java中有Synchronized概念，可以用來保護單個方法，但如果一個共享類有多個同步方法，可能就會有些問題了。

建議 : 避免用一個共享對象多個方法

若還是必須使用，可使用以下方法

- 基於客戶端的鎖定 : 在呼叫第一個方法之前，讓客戶端鎖定伺服器，並確保鎖定的範圍包括呼叫最後一個方法的程式。
- 基於伺服器的鎖定 : 在伺服器內建立一個方法，鎖定伺服器，呼叫所有方法，然後解鎖。 讓客戶端呼叫新方法。
- 適應伺服器 : 建立一個執行鎖定的中介。 這是一個基於伺服器的鎖定檢查，無法更改原始伺服器。

## 13.7 保持同步區微小

同步關鍵字引入了一個鎖。 由同一鎖保護的所有程式部分保證在任何給定時間只有一個執行緒透過它們執行。 鎖很昂貴，因為它們會造成延遲並增加開銷。 因此，我們不想用同步語句來處理我們的程式。 另一方面，必須保護關鍵部分，因此，我們希望用儘可能少的關鍵部分來設計我們的程式。

一些天真的程式設計師試圖透過讓他們的關鍵部分變得非常大來實現這一點。 然而，將同步擴充套件到最小關鍵部分之外會增加爭議並降低效能。

建議：保持同步部分儘可能小。


## 13.8 很難編寫正確的關閉代碼

編寫一段時間後穩定關閉的代碼是很困難的。
常見的問題與死鎖有關，當線程一直等待永遠不會到來的資料。
假如有個父線程分裂出數個子線程，其它一個子線程死鎖的話，父線程就都不能正常關閉，系統就永遠無法正常關閉了。
或者當一個生產線程收到關閉訊號關閉，而生產者線程還在等資料時，就會發生鎖定無法正常關閉的狀態導致死鎖。

建議 : 編寫代碼時盡早考慮關閉問題。

## 13.9 測試線程代碼

證明程式正確是不切實際的。 測試不能保證正確性。 無論如何，良好的測試可以最大限度地降低風險。 在單執行緒解決方案中，這都是真的。 一旦有兩個或多個執行緒使用相同的程式並處理共享資料，事情就會變得更加複雜。
建議：編寫有可能暴露問題的測試，然後使用不同的程式配置、系統配置和負載頻繁執行它們。 如果測試失敗，請追蹤失敗。 不要僅僅因為測試在後續執行中透過而忽視失敗。 這需要考慮很多。 以下是一些更細粒度的建議：
- 將虛假故障視為候選執行緒問題。
- 首先讓您的非執行緒程式工作。
- 使您的執行緒程式可插拔。 •使您的執行緒程式可調諧。
- 執行的執行緒比處理器多。 •在不同的平臺上執行。
- 測量您的程式以嘗試和強制失敗。

### 13.9.1 Treat Spurious Failures as Candidate Threading Issues

執行緒程式會導致“不可能失敗”的事情失敗。 大多數開發人員對執行緒與其他程式（包括作者）的互動沒有直觀的感覺。 執行緒程式中的錯誤可能會在一千次或一百萬次執行中表現出其症狀。 重複系統的嘗試可能令人沮喪。 這往往導致開發人員將故障視為宇宙射線、硬體故障或其他型別的“一次性”。 最好假設一次性不存在。 忽略這些“一次性”的時間越長，在潛在故障方法之上構建的程式就越多。
建議：不要將系統故障視為一次性故障。

### 13.9.2 Get Your Nonthreaded Code Working First

這似乎很明顯，但加強它也無妨。 確保程式在執行緒中使用之外工作。 一般來說，這意味著建立由您的執行緒呼叫的POJO。 POJOs沒有執行緒感知，因此可以在執行緒環境之外進行測試。 您可以在此類POJO中放置的系統越多越好。
建議：不要試圖同時追逐非執行緒錯誤和執行緒錯誤。 確保您的程式在執行緒之外工作。

### 13.9.3 Make Your Threaded Code Pluggable

編寫併發支援程式，使其可以在以下執行
- 單線程與多線程
- 測試與正式代碼
- 運行速度快速、緩慢
- 可運行一定數量的跌代
  建議：使基於執行緒的程式特別可插拔，以便您可以在各種配置下執行它。

### 13.9.4 Make Your Threaded Code Tunable

獲得正確的執行緒平衡通常需要嘗試錯誤。 早期，找到在不同配置下計時系統效能的方法。 允許數量容易調整的執行緒。 考慮在系統執行時允許它更改。 考慮允許基於吞吐量和系統利用率的自調。

### 13.9.5 Run with More Threads Than Processors

當系統在任務之間切換時，會發生一些事情。 為了促使任務交換的發生，使用比處理器或核心更多的執行緒執行。 您的任務交換越頻繁，您就越有可能遇到缺少關鍵部分或導致死鎖的程式。

### 13.9.6 Run on Different Platforms

不同的作業系統有不同的執行緒策略，每個策略都影響程式的執行。 多執行緒程式在不同環境中的行為不同。應該在每個潛在的部署環境中執行測試。
建議：儘早並經常在所有目標平臺上執行執行緒程式。

### 13.9.7 Instrument Your Code to Try and Force Failures

併發程式隱藏缺陷。 簡單的測試通常不會暴露它們。 事實上，它們在正常處理過程中經常躲起來。 他們可能會每隔幾個小時、幾天或幾周出現一次！

執行緒錯誤可能不常見、零星且難以重複的原因是，在數千條可能的途徑中，只有極少數途徑實際上失敗了。 因此，採取失敗途徑的可能性可能非常低。 這使得檢測和除錯變得非常困難。

你如何增加捕捉這種罕見事件的機會？ 您可以透過新增對Object.wait()、Object.sleep()、Object.yield()和Object.priority()等方法的呼叫來測量程式並強制其以不同的順序執行。
這些方法中的每一種都會影響執行順序，從而增加檢測缺陷的機率。 當損壞的程式儘早和儘可能頻繁地失敗時會更好。

有兩個選項：
- 手工編碼(Hand-Coded)
- 自動化

#### Hand-Coded
您可以在程式中手動插入對wait（）、sleep（）、yiyld（）和priority（）的呼叫。 當你在測試一段特別棘手的程式時，這可能就是你要做的事情。 以下是這樣做的一個例子：
```

public synchronized String nextUrlOrNull() { 
    if(hasNext()) {
        String url = urlGenerator.next(); 
        Thread.yield(); // inserted for testing        
        updateHasNext();
        return url;
    }
    return null; 
}

```

插入的yield（）來改變程式的執行路徑，可能導致程式在以前沒有失敗的地方失敗。
如果程式確實報錯，那不是因為添加yield()。而是你的程式有問題，這只是讓問題變得明顯。

這種方法有很多毛病：
- 您必須手動找到合適的地方來做這件事。
- 您如何知道將呼叫放在哪裡以及使用哪種呼叫？
- 將此類程式留在生產環境中會減慢程式速度。
- 可能發現問題也可能沒有。 運行結果不在自己的掌控中。

我們需要的是在測試期間做到這一點，而不是在生產中。
我們還需要輕鬆地混合不同執行之間的配置，從而增加發現錯誤的機會。
顯然，如果我們將系統劃分為對執行緒一無所知的POJO和控制執行緒的類，那麼就更容易找到合適的地方來測量程式。
此外，我們可以建立許多不同的方式調用，sleep、yield等方法進行POJO測試。

### 13.9.9 自動化

您可以使用面Aspect-Oriented Framework、CGLIB或ASM等工具來寫程式程式化您的程式。
例如，您可以使用有單一方法的類：
```
public class ThreadJigglePoint { 
    public static void jiggle() { 
    }
}
```
可以在代碼的不同位子調用這個方法:
```

public synchronized String nextUrlOrNull() { 
    if(hasNext()) {
        ThreadJiglePoint.jiggle(); 
        String url = urlGenerator.next();
        ThreadJiglePoint.jiggle(); 
        updateHasNext(); 
        ThreadJiglePoint.jiggle(); 
        return url;
    }
    return null; 
}
```


或者想象ThreadJigglePoint類有兩個實現。 第一個實施搖擺不動，什麼都不做，用於生產。 第二個生成一個隨機數，在sleeping、yielding 或 falling 中進行選擇。 如果你用隨機抖動執行一千次測試，你可能會就會找到一些問題。 如果測試透過，至少你可以說你已經做了盡職調查。 雖然這種方法有點簡單，但這可能是一個合理的選擇，而不是更復雜的工具。
IBM開發了一個名為ConTest的工具能做類似的事情，但它做得較複雜。
關鍵是異動程式，以便執行緒在不同時間以不同的順序執行。 寫得好的測試和異動相結合，可以大大增加發現錯誤的機會。
建議：使用異動策略來找出錯誤。

## 3.10 小結

併發程式很難正確。 當多個執行緒和共享資料混合時，簡單遵循的程式可能會變得非常可怕。 如果面臨併發程式，需要嚴格編寫乾淨的程式，否則將面臨微妙和罕見的問題。

遵循單一責任原則。 將您的系統分解為POJO，將執行緒中無關聯的代碼抽離。確保在測試執行多執行續程式時不會測試到其他的問題。執行緒程式應該是小而集中的。

瞭解併發問題的可能來源：在共享資料上執行的多個執行緒，或使用公共資源池。 邊界情況，如乾淨地關閉或完成迴圈迭代，可能特別棘手。

學習你的圖書館，瞭解基本演算法。 瞭解庫提供的一些功能如何支援解決類似於基本演算法的問題。
瞭解如何找到必須鎖定的程式區域並鎖定它們。不要鎖定不需要鎖定的程式區域。避免從另一個鎖定部分呼叫一個部分。 這需要深入瞭解撈取的資源是否被共享。 儘可能縮小共享物件的數量和共享範圍。 更改具有共享資料的物件的設計，以適應客戶端，而不是強制客戶端管理共享狀態。

問題會出現。 那些不及早出現的往往被記為一次性事件。 這些所謂的一次性事件通常只在負載下或看似隨機的時間發生。 因此，您需要能夠在許多平臺上的許多配置中反覆連續地執行與執行緒相關的程式。 可測試性自然來自遵循TDD的三定律，意味著某種程度的插拔能力，這為在更廣泛的配置中執行程式提供了必要的支援。

如果您花時間測量程式，您將大大提高找到錯誤程式的機會。 您可以手動或使用某種自動化技術。 儘早投資。 在將基於執行緒的程式投入生產之前，您希望儘可能長時間地執行基於執行緒的程式。

如果你採取整潔的方法，你做對的機會將大大增加。