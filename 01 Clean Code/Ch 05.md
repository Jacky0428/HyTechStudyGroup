# Chapter 5 - Formatting

When people look under the hood, we want them to be impressed with the neatness, con- sistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. If instead they see a scrambled mass of code that looks like it was written by a bevy of drunken sailors, then they are likely to conclude that the same inattention to detail pervades every other aspect of the project.

當人們在引擎蓋下看時，我們希望他們對他們感知到的整潔、堅持和對細節的關注印象深刻。 我們希望他們被秩序所打動。 我們希望他們在滾動模組時眉毛上升。 我們希望他們意識到專業人士一直在工作。 相反，如果他們看到一大堆看起來像是由一群醉酒的水手編寫的混亂的程式，那麼他們可能會得出結論，專案的其他每個方面都充斥著同樣的對細節的疏忽。

You should take care that your code is nicely formatted. You should choose a set of simple rules that govern the format of your code, and then you should consistently apply those rules. If you are working on a team, then the team should agree to a single set of formatting rules and all members should comply. It helps to have an automated tool that can apply those formatting rules for you.

您應該注意您的程式格式良好。 您應該選擇一套管理程式格式的簡單規則，然後您應該始終如一地應用這些規則。 如果您正在團隊中工作，那麼團隊應該同意一套格式規則，所有成員都應該遵守。 擁有一個可以為您應用這些格式規則的自動化工具會有所幫助。

- **The Purpose of Formatting**

  First of all, let’s be clear. Code formatting is *important*. It is too important to ignore and it is too important to treat religiously. Code formatting is about communication, and communication is the professional developer’s first order of business.

  首先，讓我們明確一點。 程式格式化很重要。 忽視太重要了，宗教對待也太重要了。 程式格式化與溝通有關，溝通是專業開發人員的第一訂單。

  Perhaps you thought that “getting it working” was the first order of business for a professional developer. I hope by now, however, that this book has disabused you of that idea. The functionality that you create today has a good chance of changing in the next release, but the readability of your code will have a profound effect on all the changes that will ever be made. The coding style and readability set precedents that continue to affect maintainability and extensibility long after the original code has been changed beyond recognition. Your style and discipline survives, even though your code does not.

  也許你認為“讓它發揮作用”是專業開發人員的首要業務。 然而，我現在希望這本書已經讓你否認了這個想法。 您今天建立的功能很有可能在下一個版本中發生變化，但程式的可讀性將對將進行的所有更改產生深遠影響。 編碼風格和可讀性開創了先例，在原始程式被更改得無法辨認很久之後，繼續影響可維護性和可擴充套件性。 你的風格和紀律仍然存在，即使你的程式沒有。

  So what are the formatting issues that help us to communicate best?

  那麼，有助於我們最好溝通的格式問題是什麼？

- **(done)Vertical Formatting 垂直格式**

    ```
    總結：
    - Java中不同類型檔案大小差異很大，不同的專案風格可能從數百到數千不等
    - 作者分析幾個大型開源專案的檔案程式碼行數，
    得出結論是一個檔案盡量維持在200行，上限為500行
    - 不是硬性規定，而是小文件比大文件更容易理解維護
    ```

  Let’s start with vertical size. How big should a source file be? In Java, file size is closely related to class size. We’ll talk about class size when we talk about classes. For the moment let’s just consider file size.

  讓我們從垂直尺寸開始。 源檔案應該有多大？ 在Java中，檔案大小與類大小密切相關。 我們在談論班級時會談論班級規模。 目前，讓我們考慮一下檔案大小。

  How big are most Java source files? It turns out that there is a huge range of sizes and some remarkable differences in style. Figure 5-1 shows some of those differences.

  大多數Java源檔案有多大？ 事實證明，尺寸種類繁多，風格也存在一些顯著差異。 圖5-1顯示了其中一些差異。

  Seven different projects are depicted. Junit, FitNesse, testNG, Time and Money, JDepend, Ant, and Tomcat. The lines through the boxes show the minimum and maxi- mum file lengths in each project. The box shows approximately one-third (one standard deviation1) of the files. The middle of the box is the mean. So the average file size in the FitNesse project is about 65 lines, and about one-third of the files are between 40 and 100+ lines. The largest file in FitNesse is about 400 lines and the smallest is 6 lines. Note that this is a log scale, so the small difference in vertical position implies a very large difference in absolute size.

  描繪了七個不同的專案。 Junit、FitNesse、testNG、Time and Money、JDepend、Ant和Tomcat。 穿過框的行顯示了每個專案的最小和最大檔案長度。 該框顯示了大約三分之一的檔案（一個標準差1）。 盒子的中間是平均值。 因此，FitNesse專案的平均檔案大小約為65行，約三分之一的檔案在40至100多行之間。 FitNesse中最大的檔案約為400行，最小的檔案為6行。 請注意，這是一個對數尺度，所以垂直位置的微小差異意味著絕對大小的差異非常大。

  Junit, FitNesse, and Time and Money are composed of relatively small files. None are over 500 lines and most of those files are less than 200 lines. Tomcat and Ant, on the other hand, have some files that are several thousand lines long and close to half are over 200 lines.

  Junit、FitNesse和Time and Money由相對較小的檔案組成。 沒有一個超過500行，其中大多數檔案少於200行。 另一方面，Tomcat和Ant有一些長達數千行的檔案，接近一半超過200行。

  What does that mean to us? It appears to be possible to build significant systems (FitNesse is close to 50,000 lines) out of files that are typically 200 lines long, with an upper limit of 500. Although this should not be a hard and fast rule, it should be considered very desirable. Small files are usually easier to understand than large files are.

  這對我們意味著什麼？ 似乎有可能用通常200行長的檔案構建重要的系統（FitNesse接近50,000行），上限為500行。 雖然這不應該是一個艱難和快速的規則，但它應該被認為是非常可取的。 小檔案通常比大檔案更容易理解。

- **The Newspaper Metaphor 報紙隱喻**

    ```
    作者用報紙比喻，程式碼應該要像報紙一樣組織，標題就能清晰表達內容
    ```

  Think of a well-written newspaper article. You read it vertically. At the top you expect a headline that will tell you what the story is about and allows you to decide whether it is something you want to read. The first paragraph gives you a synopsis of the whole story, hiding all the details while giving you the broad-brush concepts. As you continue down- ward, the details increase until you have all the dates, names, quotes, claims, and other minutia.

  想想一篇寫得很好的報紙文章。 你垂直閱讀它。 在頂部，你期待一個標題，告訴你故事的內容，並讓你決定它是否是你想讀的東西。 第一段為您提供了整個故事的概要，隱藏了所有細節，同時為您提供了寬闊的概念。 隨著你繼續向下ward，細節會增加，直到你得到所有日期、姓名、報價、索賠和其他細節。

  We would like a source file to be like a newspaper article. The name should be simple but explanatory. The name, by itself, should be sufficient to tell us whether we are in the right module or not. The topmost parts of the source file should provide the high-level concepts and algorithms. Detail should increase as we move downward, until at the end we find the lowest level functions and details in the source file.

  我們希望源檔案像報紙文章一樣。 這個名字應該簡單但解釋性。 這個名字本身就足以告訴我們我們是否處於正確的模組中。 源檔案的最頂部應該提供高階概念和演算法。 隨著我們向下移動，細節應該會增加，直到最後我們在源檔案中找到最低級別的功能和詳細資訊。

  A newspaper is composed of many articles; most are very small. Some are a bit larger. Very few contain as much text as a page can hold. This makes the newspaper *usable*. If the newspaper were just one long story containing a disorganized agglomeration of facts, dates, and names, then we simply would not read it.

  報紙由許多文章組成；大多數都很小。 有些稍微大一點。 很少有人能像頁面一樣包含那麼多文字。 這使得報紙變得可用。 如果這份報紙只是一個包含雜亂無章的事實、日期和名字的長篇故事，那麼我們根本不會讀它。

- **(done)Vertical Openness Between Concepts 概念之間的垂直開放**

    ```java
    //排版與空行對可讀性的影響
    //bad
    //Listing 5-2
    //BoldWidget.java
    package fitnesse.wikitext.widgets;
    import java.util.regex.*;
    public class BoldWidget extends ParentWidget {
        public static final String REGEXP = "'''.+?'''";
        private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
        Pattern.MULTILINE + Pattern.DOTALL);
        public BoldWidget(ParentWidget parent, String text) throws Exception {
            super(parent);
            Matcher match = pattern.matcher(text);
            match.find();
            addChildWidgets(match.group(1));}
        public String render() throws Exception {
            StringBuffer html = new StringBuffer("<b>");
            html.append(childHtml()).append("</b>");
            return html.toString();
        }
    }
    
    //good
    //Listing 5-1
    //BoldWidget.java
    package fitnesse.wikitext.widgets;
    import java.util.regex.*;
    
    public class BoldWidget extends ParentWidget {
    
        public static final String REGEXP = "'''.+?'''";
        private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
            Pattern.MULTILINE + Pattern.DOTALL
        );
    
        public BoldWidget(ParentWidget parent, String text) throws Exception {
            super(parent);
            Matcher match = pattern.matcher(text);
            match.find();
            addChildWidgets(match.group(1));
        }
    
        public String render() throws Exception {
            StringBuffer html = new StringBuffer("<b>");
            html.append(childHtml()).append("</b>");
            return html.toString();
        }
    }
    ```

  Nearly all code is read left to right and top to bottom. Each line represents an expression or a clause, and each group of lines represents a complete thought. Those thoughts should be separated from each other with blank lines.

  幾乎所有的程式都是從左到右、從上到下讀取的。 每行代表一個表達式或子句，每組行代表一個完整的思想。 這些想法應該用空白線彼此分開。

  Consider, for example, Listing 5-1. There are blank lines that separate the package declaration, the import(s), and each of the functions. This extremely simple rule has a pro- found effect on the visual layout of the code. Each blank line is a visual cue that identifies a new and separate concept. As you scan down the listing, your eye is drawn to the first line that follows a blank line.

  例如，考慮清單5-1。 有空白行分隔包裹申報、匯入和每個功能。 這個極其簡單的規則對程式的視覺佈局產生了pro發現的影響。 每條空白行都是一個視覺線索，可以識別一個新的獨立概念。 當你掃描列表時，你的眼睛會被吸引到空白線後的第一行。

    ```java
    //Listing 5-1
    //BoldWidget.java
    package fitnesse.wikitext.widgets;
    import java.util.regex.*;
    
    public class BoldWidget extends ParentWidget {
    
        public static final String REGEXP = "'''.+?'''";
        private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
            Pattern.MULTILINE + Pattern.DOTALL
        );
    
        public BoldWidget(ParentWidget parent, String text) throws Exception {
            super(parent);
            Matcher match = pattern.matcher(text);
            match.find();
            addChildWidgets(match.group(1));
        }
    
        public String render() throws Exception {
            StringBuffer html = new StringBuffer("<b>");
            html.append(childHtml()).append("</b>");
            return html.toString();
        }
    }
    ```

  Taking those blank lines out, as in Listing 5-2, has a remarkably obscuring effect on the readability of the code.

  像清單5-2一樣，刪除這些空白行會對程式的可讀性產生顯著模糊的影響。

    ```java
    //Listing 5-2
    //BoldWidget.java
    package fitnesse.wikitext.widgets;
    import java.util.regex.*;
    public class BoldWidget extends ParentWidget {
        public static final String REGEXP = "'''.+?'''";
        private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
        Pattern.MULTILINE + Pattern.DOTALL);
        public BoldWidget(ParentWidget parent, String text) throws Exception {
            super(parent);
            Matcher match = pattern.matcher(text);
            match.find();
            addChildWidgets(match.group(1));}
        public String render() throws Exception {
            StringBuffer html = new StringBuffer("<b>");
            html.append(childHtml()).append("</b>");
            return html.toString();
        }
    }
    ```

  This effect is even more pronounced when you unfocus your eyes. In the first example the different groupings of lines pop out at you, whereas the second example looks like a muddle. The difference between these two listings is a bit of vertical openness.

  當你不聚焦眼睛時，這種效果會更加明顯。 在第一個例子中，不同的線條組向你彈出，而第二個例子看起來像一個混亂。 這兩個列表之間的區別是有點垂直開放。

- **(done)Vertical Density 垂直密度**

    ```java
    //跟上一節類似，無用註解會影響到可讀性
    
    //bad
    //Listing 5-3
    public class ReporterConfig {
        /**
        * The class name of the reporter listener
        */
        private String m_className;
    
        /**
        * The properties of the reporter listener
        */
        private List<Property> m_properties = new ArrayList<Property>();
        public void addProperty(Property property) {
            m_properties.add(property);
        }
    }
    
    //good
    //Listing 5-4
    public class ReporterConfig {
        private String m_className;
        private List<Property> m_properties = new ArrayList<Property>();
    
        public void addProperty(Property property) {
            m_properties.add(property);
        }
    }
    ```

  If openness separates concepts, then vertical density implies close association. So lines of code that are tightly related should appear vertically dense. Notice how the useless comments in Listing 5-3 break the close association of the two instance variables.

  如果開放性將概念分開，那麼垂直密度意味著密切關聯。 因此，密切相關的程式行應該看起來垂直密集。 注意清單5-3中的無用評論如何打破兩個例項變數的密切關聯。

    ```java
    //Listing 5-3
    
    public class ReporterConfig {
        /**
        * The class name of the reporter listener
        */
        private String m_className;
    
        /**
        * The properties of the reporter listener
        */
        private List<Property> m_properties = new ArrayList<Property>();
        public void addProperty(Property property) {
            m_properties.add(property);
        }
    }
    ```

  Listing 5-4 is much easier to read. It fits in an “eye-full,” or at least it does for me. I can look at it and see that this is a class with two variables and a method, without having to move my head or eyes much. The previous listing forces me to use much more eye and head motion to achieve the same level of comprehension.

  清單5-4更容易閱讀。 它適合“滿眼”，或者至少適合我。 我可以看著它，發現這是一個有兩個變數和一個方法的類，不需要經常移動我的頭或眼睛。 之前的列表迫使我使用更多的眼睛和頭部動作來達到相同的理解水準。

    ```java
    //Listing 5-4
    public class ReporterConfig {
        private String m_className;
        private List<Property> m_properties = new ArrayList<Property>();
    
        public void addProperty(Property property) {
            m_properties.add(property);
        }
    }
    ```

- **(done)Vertical Distance 垂直距離**

    ```java
    /**=========Variable Declarations 宣告變數=========**/
    //good
    private static void readPreferences() {
        InputStream is= null; //<---- 變數應該要在方法頂端
        try {
            is= new FileInputStream(getPreferencesFile());
            setPreferences(new Properties(getPreferences()));
            getPreferences().load(is);
        } catch (IOException e) {
            try {
                if (is != null)
                    is.close();
                } catch (IOException e1) {
            }
        }
    }
    
    //another case
    //bad
    public int countTestCases() {
        count = 0;
        Test each;
        for (int j = 0; j < tests.length; j++) {
            each = tests[j];
            count += each.countTestCases();
        }
        return count;
    }
    
    //good
    public int countTestCases() {
        int count= 0;
        for (Test each : tests) // <---
            count += each.countTestCases();
        return count;
    }
    
    /**=========Instance variables 物件變數=========**/
    //bad
    public class UserDaoService {
        public List<User> findAll(){
            return users;
        }
        public User save(User user){
            user.setId(++userCount);
            users.add(user);
            return user;
        }
        public User findOne(int id){
            Predicate<? super User> predicate = user -> user.getId().equals(id);
            return users.stream().filter(predicate).findFirst().orElse(null);
        }
        public void deleteById(int id){
            Predicate<? super User> predicate = user -> user.getId().equals(id);
            users.removeIf(predicate);
        }
    
        private static List<User> users = new ArrayList<>(); // <---
        private static int userCount = 0;// <---
    
    }
    
    /**=========Dependent Functions 依賴方法=========**/
    //good
    //Listing 5-5
    //WikiPageResponder.java
    public class WikiPageResponder implements SecureResponder {
    protected WikiPage page;
    protected PageData pageData;
    protected String pageTitle;
    protected Request request;
    protected PageCrawler crawler;
    
    public Response makeResponse(FitNesseContext context, Request request) throws Exception {
        String pageName = getPageNameOrDefault(request, "FrontPage"); //<-- "FrontPage"這個Constant為了避免藏到其他方法，因此直接在呼叫的地方顯示會更好
        loadPage(pageName, context);
        if (page == null)
            return notFoundResponse(context, request);
        else
            return makePageResponse(context);
        }
    
        private String getPageNameOrDefault(Request request, String defaultPageName) {
            String pageName = request.getResource();
            if (StringUtil.isBlank(pageName))
                pageName = defaultPageName;
            return pageName;
        }
    
        protected void loadPage(String resource, FitNesseContext context) throws Exception {
            WikiPagePath path = PathParser.parse(resource);
            crawler = context.root.getPageCrawler();
            crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
            page = crawler.getPage(context.root, path);
            if (page != null)
                pageData = page.getData();
        }
    
        private Response notFoundResponse(FitNesseContext context, Request request) throws Exception {
            return new NotFoundResponder().makeResponse(context, request);
        }
    
        private SimpleResponse makePageResponse(FitNesseContext context) throws Exception {
            pageTitle = PathParser.render(crawler.getFullPath(page));
            String html = makeHtml(context);
    
            SimpleResponse response = new SimpleResponse();
            response.setMaxAge(0); response.setContent(html);
            return response;
    } ...
    
    /**=========Conceptual Affinity 概念親和力=========**/
    public class Assert {
    static public void assertTrue(String message, boolean condition) {
        if (!condition)
            fail(message);
        }
        static public void assertTrue(boolean condition) {
            assertTrue(null, condition);
        }
        static public void assertFalse(String message, boolean condition) {
            assertTrue(message, !condition);
        }
        static public void assertFalse(boolean condition) {
            assertFalse(null, condition);
    } ...
    
    ```

  Have you ever chased your tail through a class, hopping from one function to the next, scrolling up and down the source file, trying to divine how the functions relate and operate, only to get lost in a rat’s nest of confusion? Have you ever hunted up the chain of inheritance for the definition of a variable or function? This is frustrating because you are trying to understand *what* the system does, but you are spending your time and mental energy on trying to locate and remember *where* the pieces are.

  你是否曾經追逐過一個類，從一個函式跳到另一個函式，上下滾動源檔案，試圖猜測這些函式是如何關聯和運作的，卻迷失在混亂的老鼠窩中？ 你曾經為定義變數或函式尋找繼承鏈嗎？ 這令人沮喪，因為你試圖瞭解該系統的作用，但你正在花費你的時間和精力試圖定位和記住碎片在哪裡。

  Concepts that are closely related should be kept vertically close to each other [G10]. Clearly this rule doesn’t work for concepts that belong in separate files. But then closely related concepts should not be separated into different files unless you have a very good reason. Indeed, this is one of the reasons that protected variables should be avoided.

  密切相關的概念應該相互垂直接近[G10]。 顯然，這條規則不適用於屬於單獨檔案的概念。 但是，除非你有很好的理由，否則不應該將密切相關的概念分成不同的檔案。 事實上，這是應該避免受保護變數的原因之一。

  For those concepts that are so closely related that they belong in the same source file, their vertical separation should be a measure of how important each is to the understand- ability of the other. We want to avoid forcing our readers to hop around through our source files and classes.

  對於那些密切相關以至於屬於同一源檔案的概念，它們的垂直分離應該是衡量每個概念對對方的理解能力有多重要。 我們希望避免強迫讀者瀏覽我們的源檔案和課程。

  **Variable Declarations.** Variables should be declared as close to their usage as possi- ble. Because our functions are very short, local variables should appear a the top of each function, as in this longish function from Junit4.3.1.

  可變宣告。 變數應儘可能接近其使用。 由於我們的函式非常短，區域性變數應該出現在每個函式的頂部，就像Junit4.3.1中的這個長函式一樣。

    ```java
    private static void readPreferences() {
        InputStream is= null; //<----
        try {
            is= new FileInputStream(getPreferencesFile());
            setPreferences(new Properties(getPreferences()));
            getPreferences().load(is);
        } catch (IOException e) {
            try {
                if (is != null)
                    is.close();
                } catch (IOException e1) {
            }
        }
    }
    ```

  Control variables for loops should usually be declared within the loop statement, as in this cute little function from the same source.

  迴圈的控制變數通常應該在迴圈語句中宣告，就像來自同一來源的這個可愛的小函式一樣。

    ```java
    public int countTestCases() {
        int count= 0;
        for (Test each : tests) // <---
            count += each.countTestCases();
        return count;
    }
    ```

  In rare cases a variable might be declared at the top of a block or just before a loop in a long-ish function. You can see such a variable in this snippet from the midst of a very long function in TestNG.

  在極少數情況下，變數可能會在塊的頂部或長函式的迴圈前宣告。 您可以在TestNG中一個非常長的函式中看到此片段中的這樣一個變數。

    ```java
    ...
    for (XmlTest test : m_suite.getTests()) {
        TestRunner tr = m_runnerFactory.newTestRunner(this, test);// <---
        tr.addListener(m_textReporter);
        m_testRunners.add(tr);
    
        invoker = tr.getInvoker();
    
        for (ITestNGMethod m : tr.getBeforeSuiteMethods()) {
            beforeSuiteMethods.put(m.getMethod(), m);
        }
    
        for (ITestNGMethod m : tr.getAfterSuiteMethods()) {
            afterSuiteMethods.put(m.getMethod(), m);
        }
    }
    ...
    ```

  **Instance variables,** on the other hand, should be declared at the top of the class. This should not increase the vertical distance of these variables, because in a well-designed class, they are used by many, if not all, of the methods of the class.

  另一方面，例項變數應該在類的頂部宣告。 這不應該增加這些變數的垂直距離，因為在一個設計良好的類中，它們被該類的許多（如果不是全部）方法所使用。

  There have been many debates over where instance variables should go. In C++ we commonly practiced the so-called *scissors rule*, which put all the instance variables at the bottom. The common convention in Java, however, is to put them all at the top of the class. I see no reason to follow any other convention. The important thing is for the instance vari- ables to be declared in one well-known place. Everybody should know where to go to see the declarations.

  關於例項變數應該去哪裡有很多爭議。 在C++中，我們通常練習所謂的剪刀規則，它將所有例項變數放在底部。 然而，Java的共同慣例是將它們都置於課堂之首。 我認為沒有理由遵循任何其他慣例。 重要的是，例項變數能夠在一個眾所周知的地方被宣告。 每個人都應該知道去哪裡看宣言。

  Consider, for example, the strange case of the TestSuite class in JUnit 4.3.1. I have greatly attenuated this class to make the point. If you look about halfway down the listing, you will see two instance variables declared there. It would be hard to hide them in a better place. Someone reading this code would have to stumble across the declarations by acci- dent (as I did).

  例如，考慮JUnit 4.3.1中TestSuite類的奇怪情況。 為了表明這一點，我大大減輕了這門課。 如果您檢視列表的一半左右，您將看到那裡宣告的兩個例項變數。 很難把它們藏在一個更好的地方。 讀這個程式的人必須偶然發現宣告（像我一樣）。

    ```java
    public class TestSuite implements Test {
        static public Test createTest(Class<? extends TestCase> theClass, String name) {
            ...
        }
        public static Constructor<? extends TestCase> getTestConstructor(Class<? extends TestCase> theClass)
                throws NoSuchMethodException {
            ...
        }
    
        public static Test warning(final String message) {
            ...
        }
    
        private static String exceptionToString(Throwable t) {
            ...
        }
    
        private String fName; // <---
    
        private Vector<Test> fTests= new Vector<Test>(10); // <---
    
        public TestSuite() {
        }
    
        public TestSuite(final Class<? extends TestCase> theClass) {
            ...
        }
    
        public TestSuite(Class<? extends TestCase> theClass, String name) {
            ...
        }
        ... ... ... ... ...
    }
    ```

  **Dependent Functions.** If one function calls another, they should be vertically close, and the caller should be above the callee, if at all possible. This gives the program a natural flow. If the convention is followed reliably, readers will be able to trust that function defini- tions will follow shortly after their use. Consider, for example, the snippet from FitNesse in Listing 5-5. Notice how the topmost function calls those below it and how they in turn call those below them. This makes it easy to find the called functions and greatly enhances the readability of the whole module.

  依賴函式。 如果一個函式呼叫另一個函式，它們應該垂直接近，如果可能的話，呼叫者應該在被呼叫者上方。 這給了程式一個自然的流動。 如果可靠地遵循該慣例，讀者將能夠相信功能定義在使用後不久就會遵循。 例如，考慮清單5-5中FitNesse的片段。 注意最上面的函式如何呼叫它下面的那些，以及它們如何反過來呼叫它們下面的那些。 這使得找到所謂的函式變得容易，並大大提高了整個模組的可讀性。

    ```java
    //Listing 5-5
    //WikiPageResponder.java
    public class WikiPageResponder implements SecureResponder {
    protected WikiPage page;
    protected PageData pageData;
    protected String pageTitle;
    protected Request request;
    protected PageCrawler crawler;
    
    public Response makeResponse(FitNesseContext context, Request request) throws Exception {
        String pageName = getPageNameOrDefault(request, "FrontPage"); //<-- "FrontPage"這個Constant為了避免藏到其他方法，因此直接在呼叫的地方顯示會更好
        loadPage(pageName, context);
        if (page == null)
            return notFoundResponse(context, request);
        else
            return makePageResponse(context);
        }
    
        private String getPageNameOrDefault(Request request, String defaultPageName) {
            String pageName = request.getResource();
            if (StringUtil.isBlank(pageName))
                pageName = defaultPageName;
            return pageName;
        }
    
        protected void loadPage(String resource, FitNesseContext context) throws Exception {
            WikiPagePath path = PathParser.parse(resource);
            crawler = context.root.getPageCrawler();
            crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
            page = crawler.getPage(context.root, path);
            if (page != null)
                pageData = page.getData();
        }
    
        private Response notFoundResponse(FitNesseContext context, Request request) throws Exception {
            return new NotFoundResponder().makeResponse(context, request);
        }
    
        private SimpleResponse makePageResponse(FitNesseContext context) throws Exception {
            pageTitle = PathParser.render(crawler.getFullPath(page));
            String html = makeHtml(context);
    
            SimpleResponse response = new SimpleResponse();
            response.setMaxAge(0); response.setContent(html);
            return response;
    } ...
    ```

  As an aside, this snippet provides a nice example of keeping constants at the appropri- ate level [G35]. The "FrontPage" constant could have been buried in the getPageNameOrDefault function, but that would have hidden a well-known and expected constant in an inappropriately low-level function. It was better to pass that constant down from the place where it makes sense to know it to the place that actually uses it.

  撇開邊說，這個片段提供了一個將常數保持在適當水準[G35]的好例子。 “FrontPage”常量本可以埋藏在getPageNameOrDefault函式中，但這會在一個不適當的低級函式中隱藏一個眾所周知的預期常量。 最好將這個常數從知道它有意義的地方傳到實際使用它的地方。

  **Conceptual Affinity.** Certain bits of code *want* to be near other bits. They have a certain conceptual affinity. The stronger that affinity, the less vertical distance there should be between them.

  概念親和力。 某些程式位想靠近其他位。 他們有一定的概念親和力。 親和力越強，它們之間的垂直距離就越小。

  As we have seen, this affinity might be based on a direct dependence, such as one function call- ing another, or a function using a variable. But there are other possible causes of affinity. Affinity might be caused because a group of functions per- form a similar operation. Consider this snippet of code from Junit 4.3.1:

  正如我們所看到的，這種親和力可能基於直接依賴性，例如一個函式呼叫另一個函式，或使用變數的函式。 但親和力還有其他可能的原因。 親和力可能是因為一組函式形成類似的操作。 考慮Junit 4.3.1的此程式片段：

    ```java
    public class Assert {
    static public void assertTrue(String message, boolean condition) {
        if (!condition)
            fail(message);
        }
        static public void assertTrue(boolean condition) {
            assertTrue(null, condition);
        }
        static public void assertFalse(String message, boolean condition) {
            assertTrue(message, !condition);
        }
        static public void assertFalse(boolean condition) {
            assertFalse(null, condition);
    } ...
    ```

  These functions have a strong conceptual affinity because they share a common naming scheme and perform variations of the same basic task. The fact that they call each other is secondary. Even if they didn’t, they would still want to be close together.

  這些功能具有強烈的概念親和力，因為它們共享一個共同的命名方案，並執行相同基本任務的變體。 他們互相稱呼的事實是次要的。 即使他們沒有，他們仍然想離得很近。

- **Vertical Ordering 垂直排序**

    ```java
    //Listing 5-5
    //WikiPageResponder.java
    public class WikiPageResponder implements SecureResponder {
    protected WikiPage page;
    protected PageData pageData;
    protected String pageTitle;
    protected Request request;
    protected PageCrawler crawler;
    
    public Response makeResponse(FitNesseContext context, Request request) throws Exception {
        String pageName = getPageNameOrDefault(request, "FrontPage"); //<-- "FrontPage"這個Constant為了避免藏到其他方法，因此直接在呼叫的地方顯示會更好
        loadPage(pageName, context);
        if (page == null)
            return notFoundResponse(context, request);
        else
            return makePageResponse(context);
        }
    
        private String getPageNameOrDefault(Request request, String defaultPageName) {
            String pageName = request.getResource();
            if (StringUtil.isBlank(pageName))
                pageName = defaultPageName;
            return pageName;
        }
    
        protected void loadPage(String resource, FitNesseContext context) throws Exception {
            WikiPagePath path = PathParser.parse(resource);
            crawler = context.root.getPageCrawler();
            crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
            page = crawler.getPage(context.root, path);
            if (page != null)
                pageData = page.getData();
        }
    
        private Response notFoundResponse(FitNesseContext context, Request request) throws Exception {
            return new NotFoundResponder().makeResponse(context, request);
        }
    
        private SimpleResponse makePageResponse(FitNesseContext context) throws Exception {
            pageTitle = PathParser.render(crawler.getFullPath(page));
            String html = makeHtml(context);
    
            SimpleResponse response = new SimpleResponse();
            response.setMaxAge(0); response.setContent(html);
            return response;
    } ...
    
    //Listing 15-5
    //ComparisonCompactor.java (final)
    public class ComparisonCompactor {
        private static final String ELLIPSIS = "...";
        private static final String DELTA_END = "]";
        private static final String DELTA_START = "[";
    
        private int contextLength;
        private String expected;
        private String actual;
        private int prefixLength;
        private int suffixLength;
    
        public ComparisonCompactor(int contextLength, String expected, String actual) {
            {
                this.contextLength = contextLength;
                this.expected = expected;
                this.actual = actual;
            }
    
            public String formatCompactedComparison (String message){
                String compactExpected = expected;
                String compactActual = actual;
                if (shouldBeCompacted()) {
                    findCommonPrefixAndSuffix();
                    compactExpected = compact(expected);
                    compactActual = compact(actual);
                }
                return Assert.format(message, compactExpected, compactActual);
            }
    
            private boolean shouldBeCompacted () {
                return !shouldNotBeCompacted();
            }
    
            private boolean shouldNotBeCompacted () {
                return expected == null ||
                        actual == null || expected.equals(actual);
            }
    
            private void findCommonPrefixAndSuffix () {
                findCommonPrefix();
                suffixLength = 0;
                for (; !suffixOverlapsPrefix(); suffixLength++) {
                    if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)
                    )
                        break;
                }
            }
    
            private char charFromEnd (String s,int i){
                return s.charAt(s.length() - i - 1);
            }
    
            private boolean suffixOverlapsPrefix () {
                return actual.length() - suffixLength <= prefixLength ||
                        expected.length() - suffixLength <= prefixLength;
            }
    
            private void findCommonPrefix () {
                prefixLength = 0;
                int end = Math.min(expected.length(), actual.length());
                for (; prefixLength < end; prefixLength++)
                    if (expected.charAt(prefixLength) != actual.charAt(prefixLength)) break;
            }
    
            private String compact (String s){
                return new StringBuilder()
                        .append(startingEllipsis()).append(startingContext()).append(DELTA_START).append(delta(s)).append(DELTA_END).append(endingContext()).append(endingEllipsis()).toString();
            }
    
            private String startingEllipsis () {
                return prefixLength > contextLength ? ELLIPSIS : "";
            }
    
            private String startingContext () {
                int contextStart = Math.max(0, prefixLength - contextLength);
                int contextEnd = prefixLength;
                return expected.substring(contextStart, contextEnd);
            }
    
            private String delta (String s){
                int deltaStart = prefixLength;
                int deltaEnd = s.length() - suffixLength;
                return s.substring(deltaStart, deltaEnd);
            }
    
            private String endingContext () {
                int contextStart = expected.length() - suffixLength;
                int contextEnd =
                        Math.min(contextStart + contextLength, expected.length());
                return expected.substring(contextStart, contextEnd);
            }
    
            private String endingEllipsis () {
                return (suffixLength > contextLength ? ELLIPSIS : "");
            }
        }
    }
    
    //Listing 3-7
    //SetupTeardownIncluder.java
    public class SetupTeardownIncluder {
        private PageData pageData;
        private boolean isSuite;
        private WikiPage testPage;
        private StringBuffer newPageContent;
        private PageCrawler pageCrawler;
    
        public static String render(PageData pageData) throws Exception {
            return render(pageData, false);
        }
    
        public static String render(PageData pageData, boolean isSuite) throws Exception {
            return new SetupTeardownIncluder(pageData).render(isSuite);
        }
    
        private SetupTeardownIncluder(PageData pageData) {
            this.pageData = pageData;
            testPage = pageData.getWikiPage();
            pageCrawler = testPage.getPageCrawler();
            newPageContent = new StringBuffer();
        }
    
        private String render(boolean isSuite) throws Exception {
            this.isSuite = isSuite;
            if (isTestPage())
                includeSetupAndTeardownPages();
            return pageData.getHtml();
        }
    
        private boolean isTestPage() throws Exception {
            return pageData.hasAttribute("Test");
        }
    
        private void includeSetupAndTeardownPages() throws Exception {
            includeSetupPages();
            includePageContent();
            includeTeardownPages();
            updatePageContent();
        }
    
        private void includeSetupPages() throws Exception {
            if (isSuite)
                includeSuiteSetupPage();
            includeSetupPage();
        }
    
        private void includeSuiteSetupPage() throws Exception {
            include(SuiteResponder.SUITE_SETUP_NAME, "-setup");
        }
    
        private void includeSetupPage() throws Exception {
            include("SetUp", "-setup");
        }
    
        private void includePageContent() throws Exception {
            newPageContent.append(pageData.getContent());
        }
    
        private void includeTeardownPages() throws Exception {
            includeTeardownPage();
            if (isSuite)
                includeSuiteTeardownPage();
        }
    
        private void includeTeardownPage() throws Exception {
            include("TearDown", "-teardown");
        }
    
        private void includeSuiteTeardownPage() throws Exception {
            include(SuiteResponder.SUITE_TEARDOWN_NAME, "-teardown");
        }
    
        private void updatePageContent() throws Exception {
            pageData.setContent(newPageContent.toString());
        }
    
        private void include(String pageName, String arg) throws Exception {
            WikiPage inheritedPage = findInheritedPage(pageName);
            if (inheritedPage != null) {
                String pagePathName = getPathNameForPage(inheritedPage);
                buildIncludeDirective(pagePathName, arg);
            }
        }
    
        private WikiPage findInheritedPage(String pageName) throws Exception {
            return PageCrawlerImpl.getInheritedPage(pageName, testPage);
        }
    
        private String getPathNameForPage(WikiPage page) throws Exception {
            WikiPagePath pagePath = pageCrawler.getFullPath(page);
            return PathParser.render(pagePath);
        }
    
        private void buildIncludeDirective(String pagePathName, String arg) {
            newPageContent
                    .append("\n!include ")
                    .append(arg)
                    .append(" .")
                    .append(pagePathName)
                    .append("\n");
        }
    }
    ```

  In general we want function call dependencies to point in the downward direction. That is, a function that is called should be below a function that does the calling.2 This creates a nice flow down the source code module from high level to low level.

  一般來說，我們希望函式呼叫依賴關係指向向下的方向。 也就是說，被呼叫的函式應該低於進行呼叫的函式。2這在源程式模組中從高階到低層次建立了一個很好的流程。

  As in newspaper articles, we expect the most important concepts to come first, and we expect them to be expressed with the least amount of polluting detail. We expect the low-level details to come last. This allows us to skim source files, getting the gist from the first few functions, without having to immerse ourselves in the details. Listing 5-5 is organized this way. Perhaps even better examples are Listing 15-5 on page 263, and List- ing 3-7 on page 50.

  與報紙文章一樣，我們希望最重要的概念放在第一位，我們希望以最少汙染細節表達它們。 我們預計低層次的細節會最後到來。 這允許我們瀏覽源檔案，從前幾個功能，而不必沉浸在細節中。 清單55是這樣組織的。 也許更好的例子是第263頁的清單15-5和第50頁的清單3-7。

- **Horizontal Formatting 水平格式**

    ```
    水平的程式碼字數上限建議在80~120
    可以打開IDE看，最大到多少會超過螢幕導致要把視窗右滑，那就是太長了
    ```

  How wide should a line be? To answer that, let’s look at how wide lines are in typical pro- grams. Again, we examine the seven different projects. Figure 5-2 shows the distribution of line lengths of all seven projects. The regularity is impressive, especially right around 45 characters. Indeed, every size from 20 to 60 represents about 1 percent of the total number of lines. That’s 40 percent! Perhaps another 30 percent are less than 10 characters wide. Remember this is a log scale, so the linear appearance of the drop-off above 80 char- acters is really very significant. Programmers clearly prefer short lines.

  一條線應該有多寬？ 為了回答這個問題，讓我們看看典型的專業人士的線條有多寬。 我們再次考察了七個不同的專案。 圖5-2顯示了所有七個專案的線長分佈。 規律性令人印象深刻，特別是大約45個字元。 事實上，從20到60的每個尺寸都約佔總行數的1%。 那是40%！ 也許另外30%的寬度不到10個字元。 請記住，這是一個日誌尺度，所以80個字元以上下降的線性外觀確實非常重要。 程式設計師顯然更喜歡短線。

  This suggests that we should strive to keep our lines short. The old Hollerith limit of 80 is a bit arbitrary, and I’m not opposed to lines edging out to 100 or even 120. But beyond that is probably just careless.

  這表明我們應該努力縮短我們的臺詞。 80的舊霍勒里斯極限有點武斷，我不反對將線條限制到100甚至120。 但除此之外，可能只是粗心大意。

  I used to follow the rule that you should never have to scroll to the right. But monitors are too wide for that nowadays, and younger programmers can shrink the font so small hat they can get 200 characters across the screen. Don’t do that. I personally set my limit at 120.

  我曾經遵循規則，即你永遠不必向右滾動。 但如今顯示器太寬了，年輕的程式設計師可以縮小字型這麼小，他們可以在螢幕上獲得200個字元。 不要那樣做。 我個人將我的限額定為120。

    - **Horizontal Openness and Density 水平開放性和密度**

      We use horizontal white space to associate things that are strongly related and disassociate things that are more weakly related. Consider the following function:

      我們使用水準空白來關聯密切相關的東西，並解離更弱關聯的東西。 考慮以下功能：

        ```java
        private void measureLine(String line) {
          lineCount++;
          int lineSize = line.length();
          totalChars += lineSize;
          lineWidthHistogram.addLine(lineSize, lineCount);
          recordWidestLine(lineSize);
        }
        ```

      I surrounded the assignment operators with white space to accentuate them. Assignment statements have two distinct and major elements: the left side and the right side. The spaces make that separation obvious.

      我用空白包圍了分配運算子，以突出它們。 分配語句有兩個截然不同的主要元素：左側和右側。 這些空間使這種分離變得明顯。

      On the other hand, I didn’t put spaces between the function names and the opening parenthesis. This is because the function and its arguments are closely related. Separat- ing them makes them appear disjoined instead of conjoined. I separate arguments within the function call parenthesis to accentuate the comma and show that the arguments are separate.

      另一方面，我沒有在函式名稱和開頭括號之間放置空格。 這是因為函式及其引數密切相關。 分離使它們看起來脫節而不是連接。 我在函式呼叫括號中將引數分開，以突出逗號，並顯示引數是分開的。

      Another use for white space is to accentuate the precedence of operators.

      空白的另一個用途是突出運算子的優先順序。

        ```java
        public class Quadratic {
            public static double root1(double a, double b, double c) {
                double determinant = determinant(a, b, c);
                return (-b + Math.sqrt(determinant)) / (2*a);
            }
        
            public static double root2(int a, int b, int c) {
                double determinant = determinant(a, b, c);
                return (-b - Math.sqrt(determinant)) / (2*a);
            }
        
            private static double determinant(double a, double b, double c) {
                return b*b - 4*a*c;
            }
        }
        ```

      Notice how nicely the equations read. The factors have no white space between them because they are high precedence. The terms are separated by white space because addi- tion and subtraction are lower precedence.

      注意方程讀得有多好。 這些因素之間沒有空白，因為它們優先於高。 這些術語由空白分隔，因為加法和減法優先度較低。

      Unfortunately, most tools for reformatting code are blind to the precedence of operators and impose the same spacing throughout. So subtle spacings like those shown above tend to get lost after you reformat the code.

      不幸的是，大多數重新格式化程式的工具對運算子的優先順序視而不見，並在整個過程中施加相同的間距。 因此，如上所述的微妙間距往往會在您重新格式化程式後丟失。

    - **Horizontal Alignment 水平對齊**

        ```java
        //bad 如下圖
        
        //good
        public class FitNesseExpediter implements ResponseSender {
            private Socket socket;
            private InputStream input;
            private OutputStream output;
            private Request request;
            private Response response;
            private FitNesseContext context;
            protected long requestParsingTimeLimit;
            private long requestProgress;
            private long requestParsingDeadline;
            private boolean hasError;
        
            public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception
            {
                this.context = context;
                socket = s;
                input = s.getInputStream();
                output = s.getOutputStream();
                requestParsingTimeLimit = 10000;
            }
        ```

      When I was an assembly language programmer,3 I used horizontal alignment to accentuate certain structures. When I started coding in C, C++, and eventually Java, I continued to try to line up all the variable names in a set of declarations, or all the rvalues in a set of assign- ment statements. My code might have looked like this:

      當我還是裝配語言程式設計師時，3我使用水準對齊來突出某些結構。 當我開始用C、C++和最終Java編碼時，我繼續嘗試排列一組宣告中的所有變數名，或一組分配語句中的所有rvalue。 我的程式可能看起來像這樣：

      I have found, however, that this kind of alignment is not useful. The alignment seems to emphasize the wrong things and leads my eye away from the true intent. For example, in the list of declarations above you are tempted to read down the list of variable names with- out looking at their types. Likewise, in the list of assignment statements you are tempted to look down the list of rvalues without ever seeing the assignment operator. To make matters worse, automatic reformatting tools usually eliminate this kind of alignment.

      然而，我發現這種對齊毫無用處。 對齊似乎強調了錯誤的事情，並使我的目光遠離了真正的意圖。 例如，在上面的宣告列表中，您很想仔細閱讀變數名稱列表，同時檢視其型別。 同樣，在賦值語句列表中，您很想在沒有看到賦值運算子的情況下向下檢視rvalue列表。 更糟糕的是，自動重新格式化工具通常會消除這種對齊。

      So, in the end, I don’t do this kind of thing anymore. Nowadays I prefer unaligned declarations and assignments, as shown below, because they point out an important defi- ciency. If I have long lists that need to be aligned, *the problem is the length of the lists*, not the lack of alignment. The length of the list of declarations in FitNesseExpediter below suggests that this class should be split up.

      所以，最後，我不再做這種事情了。 如今，我更喜歡不一致的宣告和分配，如下圖所示，因為它們指出了重要的挑戰。 如果我有需要對齊的長列表，問題在於列表的長度，而不是缺乏對齊。 以下FitNesseExpediter中宣告列表的長度表明，該類應該拆分。

        ```java
        public class FitNesseExpediter implements ResponseSender {
            private Socket socket;
            private InputStream input;
            private OutputStream output;
            private Request request;
            private Response response;
            private FitNesseContext context;
            protected long requestParsingTimeLimit;
            private long requestProgress;
            private long requestParsingDeadline;
            private boolean hasError;
        
            public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception
            {
                this.context = context;
                socket = s;
                input = s.getInputStream();
                output = s.getOutputStream();
                requestParsingTimeLimit = 10000;
            }
        ```

    - **Indentation 壓痕/鋸齒狀**

        ```java
        //bad
        public class CommentWidget extends TextWidget {
            public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";
        
            public CommentWidget(ParentWidget parent, String text){super(parent, text);}
            public String render() throws Exception {return ""; }
        }
        
        //good
        public class CommentWidget extends TextWidget {
            public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";
        
            public CommentWidget(ParentWidget parent, String text) {
                super(parent, text);
            }
        
            public String render() throws Exception {
                return "";
            }
        }
        ```

      A source file is a hierarchy rather like an outline. There is information that pertains to the file as a whole, to the individual classes within the file, to the methods within the classes, to the blocks within the methods, and recursively to the blocks within the blocks. Each level of this hierarchy is a scope into which names can be declared and in which declara- tions and executable statements are interpreted.

      源檔案是一個層次結構，而不是一個大綱。 有與整個檔案、檔案中的各個類、類中的方法、方法中的塊以及遞迴到塊中的塊有關的資訊。 此層次結構的每個級別都是可以宣告名稱以及解釋宣告和可執行語句的範圍。

      To make this hierarchy of scopes visible, we indent the lines of source code in pro- portion to their position in the hiearchy. Statements at the level of the file, such as most class declarations, are not indented at all. Methods within a class are indented one level to the right of the class. Implementations of those methods are implemented one level to the right of the method declaration. Block implementations are implemented one level to the right of their containing block, and so on.

      為了使這個範圍層次結構可見，我們將源程式行縮排到它們在hiearchy中的位置。 檔案級別的語句，如大多數類宣告，根本不縮排。 類中的方法在類的右側縮入一個級別。 這些方法的實現在方法宣告的右側實現一個級別。 塊實現在其包含塊的右側實施一個級別，以等。

      Programmers rely heavily on this indentation scheme. They visually line up lines on the left to see what scope they appear in. This allows them to quickly hop over scopes, such as implementations of if or while statements, that are not relevant to their current situation. They scan the left for new method declarations, new variables, and even new classes. Without indentation, programs would be virtually unreadable by humans.

      程式設計師嚴重依賴這種縮進方案。 他們直觀地排列左側的線條，看看它們出現在什麼範圍內。 這允許他們快速跳過與當前情況無關的範圍，例如if或while語句的實現。 他們掃描左側的新方法宣告、新變數，甚至新類。 如果沒有壓痕，程式幾乎無法被人類讀取。

      Consider the following programs that are syntactically and semantically identical:

      考慮以下語法和語義相同的程式：

      Your eye can rapidly discern the structure of the indented file. You can almost instantly spot the variables, constructors, accessors, and methods. It takes just a few seconds to real- ize that this is some kind of simple front end to a socket, with a time-out. The unindented version, however, is virtually impenetrable without intense study.

      你的眼睛可以快速辨別縮排檔案的結構。 您幾乎可以立即發現變數、構造器、訪問器和方法。 只需要幾秒鐘就能意識到這是插座的某種簡單的前端，並且有一個超時。 然而，如果沒有深入的研究，未縮進的版本幾乎是無法滲透的。

      **Breaking Indentation.** It is sometimes tempting to break the indentation rule for short if statements, short while loops, or short functions. Whenever I have succumbed to this temptation, I have almost always gone back and put the indentation back in. So I avoid col- lapsing scopes down to one line like this:

      打破壓痕。 有時很想打破短if語句、短邊環或短函式的縮進規則。 每當我屈服於這種誘惑時，我幾乎總是回去把凹痕放回去。 因此，我避免將瞄準鏡塌陷到像這樣的一行：

        ```java
        public class CommentWidget extends TextWidget {
            public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";
        
            public CommentWidget(ParentWidget parent, String text){super(parent, text);}
            public String render() throws Exception {return ""; }
        }
        ```

      I prefer to expand and indent the scopes instead, like this:

      我更喜歡擴充套件和縮入範圍，比如這樣：

        ```java
        public class CommentWidget extends TextWidget {
            public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n|\r)?";
        
            public CommentWidget(ParentWidget parent, String text) {
                super(parent, text);
            }
        
            public String render() throws Exception {
                return "";
            }
        }
        ```

      **Dummy Scopes** 虛擬範圍

        ```java
        //Dummy Scopes 不建議使用，容易造成誤解
        //底下的while就是
        
        這一行代碼的目的是從DataInputStream (dis) 讀取數據到字節數組buf。
        read方法嘗試從輸入流dis讀取最多buf.length個字節的數據並將其存儲在buf中，從索引0開始。
        while循環會持續執行，直到read方法返回-1
        ```

      Sometimes the body of a while or for statement is a dummy, as shown below. I don’t like these kinds of structures and try to avoid them. When I can’t avoid them, I make sure that the dummy body is properly indented and surrounded by braces. I can’t tell you how many times I’ve been fooled by a semicolon silently sitting at the end of a while loop on the same line. Unless you make that semicolon *visible* by indenting it on it’s own line, it’s just too hard to see.

      `while (dis.read(buf, 0, readBufferSize) != -1) ;`

      有時一段時間或陳述的身體是一個假人，如下所示。 我不喜歡這類結構，並儘量避免它們。 當我無法避免它們時，我會確保假身體正確縮進並被牙套包圍。 我不能告訴你有多少次我被靜靜地坐在同一條線上迴圈結束時的分號所愚弄。 除非您透過在自己的行上縮排使其可見，否則它太難看到。

- **Team Rules**

  The title of this section is a play on words. Every programmer has his own favorite formatting rules, but if he works in a team, then the team rules.

  本節的標題是文字遊戲。 每個程式設計師都有自己最喜歡的格式規則，但如果他在團隊中工作，那麼團隊規則就是團隊規則。

  A team of developers should agree upon a single formatting style, and then every member of that team should use that style. We want the software to have a consistent style. We don’t want it to appear to have been written by a bunch of disagreeing individuals.

  開發人員團隊應該就單一的格式樣式達成一致，然後該團隊的每個成員都應該使用該風格。 我們希望軟體具有一致的風格。 我們不希望它看起來像是由一群持不同意見的人寫的。

  When I started the FitNesse project back in 2002, I sat down with the team to work out a coding style. This took about 10 minutes. We decided where we’d put our braces, what our indent size would be, how we would name classes, variables, and methods, and so forth. Then we encoded those rules into the code formatter of our IDE and have stuck with them ever since. These were not the rules that I prefer; they were rules decided by the team. As a member of that team I followed them when writing code in the FitNesse project.

  當我在2002年開始FitNesse專案時，我與團隊坐在一起制定編碼風格。 這花了大約10分鐘。 我們決定將大括號放在哪裡，我們的縮放大小是多少，如何命名類、變數和方法等等。 然後，我們將這些規則編碼到IDE的程式格式化程式中，並從那時起一直堅持使用它們。 這些不是我喜歡的規則；它們是由團隊決定的規則。 作為該團隊的一員，我在FitNesse專案中編寫程式時跟隨他們。

  Remember, a good software system is composed of a set of documents that read nicely. They need to have a consistent and smooth style. The reader needs to be able to trust that the formatting gestures he or she has seen in one source file will mean the same thing in others. The last thing we want to do is add more complexity to the source code by writing it in a jumble of different individual styles.

  請記住，一個好的軟體系統是由一組讀起來很好的文件組成的。 他們需要有一個一致和流暢的風格。 讀者需要能夠相信，他或她在一個源檔案中看到的格式手勢在其他檔中也會有同樣的意思。 我們最不想做的就是將源程式寫成混亂的不同風格，從而增加源程式的複雜性。

- **Uncle Bob’s Formatting Rules**

  The rules I use personally are very simple and are illustrated by the code in Listing 5-6. Consider this an example of how code makes the best coding standard document.

  我個人使用的規則非常簡單，由清單5-6中的程式說明。 考慮這是一個程式如何製作最佳編碼標準文件的例子。

    ```java
    //Listing 5-6
    //CodeAnalyzer.java
    public class CodeAnalyzer implements JavaFileAnalysis {
      private int lineCount;
      private int maxLineWidth;
      private int widestLineNumber;
      private LineWidthHistogram lineWidthHistogram;
      private int totalChars;
    
      public CodeAnalyzer() {
        lineWidthHistogram = new LineWidthHistogram();
      }
    
      public static List<File> findJavaFiles(File parentDirectory) {
        List<File> files = new ArrayList<File>();
        findJavaFiles(parentDirectory, files);
        return files;
      }
    
      private static void findJavaFiles(File parentDirectory, List<File> files) {
        for (File file : parentDirectory.listFiles()) {
          if (file.getName().endsWith(".java"))
            files.add(file);
          else if (file.isDirectory())
            findJavaFiles(file, files);
        }
      }
    
      public void analyzeFile(File javaFile) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(javaFile));
        String line;
        while ((line = br.readLine()) != null)
          measureLine(line);
      }
    
      private void measureLine(String line) {
        lineCount++;
        int lineSize = line.length();
        totalChars += lineSize;
        lineWidthHistogram.addLine(lineSize, lineCount);
        recordWidestLine(lineSize);
      }
    
      private void recordWidestLine(int lineSize) {
        if (lineSize > maxLineWidth) {
          maxLineWidth = lineSize;
          widestLineNumber = lineCount;
        }
      }
    
      public int getLineCount() {
        return lineCount;
      }
    
      public int getMaxLineWidth() {
        return maxLineWidth;
      }
    ```
    